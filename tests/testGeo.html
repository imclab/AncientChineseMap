<!DOCTYPE html>
<html>
    <head>
        <title>Geolocation and elevation test</title>
        <style type="text/css">
          html { height: 100% }
          body { height: 100%; margin: 0px; padding: 0px }
          #map_canvas { height: 100% }
          #status { color: #FF0000; position:fixed; top:15px; left:105px; z-index:200;}
        </style>
		
        <script type="text/javascript" src="../js/libs/Stats.js"></script> 
        <script type="text/javascript" src="../js/libs/webgl-utils.js"></script> 
        <script type="text/javascript" src="../js/libs/glMatrix-0.9.5.min.js"></script> 
        <script type="text/javascript" src="../js/libs/webgl-debug.js"></script> 
        <script type="text/javascript" src="../js/libs/dat.gui.min.js"></script> 
        <script type="text/javascript" src="../js/bongiovi/SimpleCamera.js"></script> 
        <script type="text/javascript" src="../js/bongiovi/HoverCamera.js"></script> 
        <script type="text/javascript" src="../js/bongiovi/ProjectionPerspectiveMatrix.js"></script> 
        <script type="text/javascript" src="../js/bongiovi/GLModelShader.js"></script> 
        <script type="text/javascript" src="../js/bongiovi/GLModel.js"></script> 
        <script type="text/javascript" src="../js/bongiovi/GLTexture.js"></script> 
        <script type="text/javascript" src="../js/bongiovi/GLTextureFilter.js"></script> 
        <script type="text/javascript" src="http://maps.google.com/maps/api/js?libraries=geometry&sensor=false&language=en"></script>


        <script id="shader-vs" type="x-shader/x-vertex">
            attribute vec3 aVertexPosition;
            attribute vec2 aTextureCoord;

            uniform mat4 uMVMatrix;
            uniform mat4 uPMatrix;

            varying vec2 vTextureCoord;

            void main(void) {
                gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
                vTextureCoord = aTextureCoord;
            }
        </script>

        <script id="shader-fs" type="x-shader/x-fragment">
            precision mediump float;

            varying vec2 vTextureCoord;

            uniform sampler2D uSampler0;

            void main(void) {
                gl_FragColor = texture2D(uSampler0, vec2(vTextureCoord.s, vTextureCoord.t));
            }
        </script>


        <script>
            window.requestAnimFrame = (function(){
                return  window.requestAnimationFrame       || 
                window.webkitRequestAnimationFrame || 
                window.mozRequestAnimationFrame    || 
                window.oRequestAnimationFrame      || 
                window.msRequestAnimationFrame     || 
                function( callback ){
                window.setTimeout(callback, 1000 / 60);
                };
            })();

            function parseQueryString(aPath) {

                var TL = [24.209394675097073, 120.673828125];
                var BR = [23.50103316052575, 121.453857421875]

                var queryString = aPath;
                var queryIndex = queryString.indexOf("?");
                var queryStringArray = [];
                
                if(queryIndex !== -1 && queryIndex+1 !== queryString.length) {
                    queryString = queryString.substring(queryIndex+1, queryString.length);
                    queryStringArray = queryString.split("&");
                }
                var returnObject = {};
                for(var i = 0; i < queryStringArray.length; i++) {
                    var tempArray = queryStringArray[i].split("=");
                    returnObject[tempArray[0]] = tempArray[1];
                }
                return returnObject;
            };

            
            var queries = parseQueryString(window.location.href);

            google.maps.Map.prototype.markers = new Array();
            google.maps.Map.prototype.getMarkers = function() {
                return this.markers
            };
            google.maps.Map.prototype.clearMarkers = function() {
                for(var i=0; i<this.markers.length; i++){
                    this.markers[i].setMap(null);
                }
                this.markers = new Array();
            };
            google.maps.Marker.prototype._setMap = google.maps.Marker.prototype.setMap;
            google.maps.Marker.prototype.setMap = function(map) {
                if (map) {
                    map.markers[map.markers.length] = this;
                }
                this._setMap(map);
            }

            var texture, canvasGL, gl, stats;


            function init() {
                console.log( "INIT" );

                canvasGL = document.createElement("canvas");
                canvasGL.id = "canvasGL";
                canvasGL.width = window.innerWidth/2;
                canvasGL.height = window.innerHeight;
                canvasGL.style.position = "absolute";
                canvasGL.style.zIndex = "0";
                canvasGL.style.left = window.innerWidth/2 + "px";

                gl = canvasGL.getContext("experimental-webgl");
                gl.viewportWidth = window.innerWidth/2;
                gl.viewportHeight = window.innerHeight;
                document.body.appendChild(canvasGL);

                stats = new Stats();
                stats.domElement.style.position = 'absolute';
                stats.domElement.style.top = '0px';
                document.body.appendChild( stats.domElement );

                var styles = [
                  {
                    "stylers": [
                      { "saturation": -100 },
                      { "lightness": 1 }
                    ]
                  },{
                    "featureType": "poi",
                    "stylers": [
                      { "visibility": "off" }
                    ]
                  },{
                    "featureType": "administrative",
                    "stylers": [
                      { "visibility": "off" }
                    ]
                  },{
                    "featureType": "landscape",
                    "stylers": [
                      { "visibility": "off" }
                    ]
                  },{
                    "featureType": "road.local",
                    "stylers": [
                      { "visibility": "simplified" }
                    ]
                  },{
                    "featureType": "road.arterial",
                    "stylers": [
                      { "visibility": "simplified" }
                    ]
                  },{
                    "featureType": "transit.station",
                    "stylers": [
                      { "weight": 5.1 }
                    ]
                  },{
                    "featureType": "transit.station",
                    "stylers": [
                      { "gamma": 0.01 }
                    ]
                  },{
                  }
                ]

                var latlng = new google.maps.LatLng(24.209394675097073, 120.673828125);

                var styledMap = new google.maps.StyledMapType(styles,   {name: "Styled Map"});  

                var myOptions = {
                    zoom: 9,   
                    center: latlng,
                    mapTypeControlOptions: {
                        mapTypeIds: [google.maps.MapTypeId.ROADMAP, 'map_style']
                    }
                };

                map = new google.maps.Map(document.getElementById("map_canvas"), myOptions);
                map.mapTypes.set('map_style', styledMap);
                map.setMapTypeId('map_style');

                elevator = new google.maps.ElevationService();

                google.maps.event.addListener(map, 'click', function(event) {
                    placeMarker(event.latLng);
                });

                var img = new Image();
                img.onload = function(e) {
                    texture = new GLTexture(gl, img);
                    console.log( "Image Loaded : " + texture );
                }
                img.src = "images/whitebg.jpg";

            }


            function placeMarker(location) {
                var marker = new google.maps.Marker({
                    position: location,
                    map: map
                });


                if(window.p0 == undefined) {
                    window.p0 = [location.lat(), location.lng()];
                } else {
                    window.p1 = [location.lat(), location.lng()];
                    getDepthMap(); 

                    window.p0 = undefined;
                    window.p1 = undefined;
                }
            }


            function getDepthMap() {
                console.log( "Draw Depth Map" );
                num = 10;
                var sx = p0[0], sy = p0[1];
                var dx = (p1[0] - sx) / num;
                var dy = (p1[1] - sy) / num;
                var x, y;
                var queries = [];
                var coords = [];
                var locations = [];
                for ( var j=0; j<num; j++) {
                    coords[j] = [];
                    var query = "http://maps.googleapis.com/maps/api/elevation/json?sensor=false&alt=json-in-script&locations=";
                    for ( var i=0; i<num; i++) {
                        x = sx + dx*i;
                        y = sy + dy*j;
                        query += (x+","+y+"|");

                        var ll = new google.maps.LatLng(x, y);
                        locations.push(ll);
                    }
                    query = query.substring(0, query.length-1);

                    var o = {q:query, j:j, data:null};
                    queries.push(o);
                }

                var positionalRequest = {   'locations': locations  };

                elevator.getElevationForLocations(positionalRequest, function(results, status) {
                    if (status == google.maps.ElevationStatus.OK) {

                        for ( var i=0; i<results.length; i++) {
                            var tx = i % num;
                            var ty = Math.floor(i/num);
                            console.log( tx + "/" + ty );
                            coords[tx][ty] = results[i].elevation;
                        }


                        drawDepthMap(queries, coords);
                    } else {
                      alert("Elevation service failed due to: " + status);
                    }
                  });

                
            };

            var model, shader, projection, camera;

            function drawDepthMap(queries, coords) {
                var size = 40;
                var offset = (num-1)*size/2;
                if(model == undefined) model = new bongiovi.GLModel(gl, (num-1)*(num-1)*4);

                for ( var i=0; i<(num-1); i++) {
                    for ( var j=0; j< (num-1); j++) {

                        var index = i*(num-1) + j;

                        var tx = queries[i].j;
                        var ty = j;

                        console.log( tx + "/" + ty + " : " + index + "   ::   " + coords[i][j] );

                        this.model.updateVertex(index*4,    tx*size-size-offset, -coords[i][j]/10,    ty*size-size-offset); 
                        this.model.updateVertex(index*4+1,  tx*size-offset, -coords[i+1][j]/10,       ty*size-size-offset); 
                        this.model.updateVertex(index*4+2,  tx*size-offset, -coords[i+1][j+1]/10,     ty*size-offset); 
                        this.model.updateVertex(index*4+3,  tx*size-size-offset, -coords[i][j+1]/10,  ty*size-offset);

                        this.model.updateTextCoord(index*4,   0, 0);
                        this.model.updateTextCoord(index*4+1, 1, 0);
                        this.model.updateTextCoord(index*4+2, 1, 1);
                        this.model.updateTextCoord(index*4+3, 0, 1); 
                    }
                }

                if(shader == undefined) shader = new bongiovi.GLModelShader(this.gl, "shader-vs", "shader-fs");
                model.setTexture(0, texture);
                model.generateBuffer();

                var W = canvasGL.width;
                var H = canvasGL.height;
                if(projection == undefined) {
                    projection = new bongiovi.ProjectionPerspectiveMatrix();
                    projection.perspective(45, W/H, .1, 10000);
                    camera = new bongiovi.HoverCamera().init(2000);   
                }
                

                loop();
            }


            function loop() {
                requestAnimFrame(loop);
                render();
                // that.stats.update();
            }


            function render() {
                gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
                gl.enable(gl.BLEND);
                gl.enable(gl.DEPTH_TEST);

                var matrix = camera.update();
                var invert = mat4.create(matrix);
                mat4.inverse(invert)

                var invertCamera = mat4.toInverseMat3(invert);
                gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

                model.render(shader, matrix, projection.matrix);
            }
        </script>
    
    </head>
        

    <body onload="init()">
        <div id="map_canvas" style="width:50%; height:100%; z-index:1; position:absolute;"></div>
    </body>
</html>